import logging
from typing import List, Dict, Any, Optional
from sqlalchemy.orm import Session
from datetime import datetime

from ..api.models.database import get_db
from ..api.models.vulnerability import Vulnerability, ComplianceFinding, SeverityLevel, VulnerabilityStatus

# Configure logging
logger = logging.getLogger(__name__)

class VulnerabilityDatabase:
    """
    Interface for storing and retrieving vulnerability information from the database.
    """
    
    def __init__(self, db_session: Optional[Session] = None):
        """
        Initialize the Vulnerability Database interface.
        
        Args:
            db_session: SQLAlchemy database session (optional, will get from dependency if not provided)
        """
        self.db_session = db_session
        
    async def store_vulnerabilities(self, vulnerabilities: List[Vulnerability]) -> int:
        """
        Store a list of vulnerabilities in the database.
        
        Args:
            vulnerabilities: List of Vulnerability objects to store
            
        Returns:
            Number of vulnerabilities stored
        """
        if not vulnerabilities:
            return 0
            
        try:
            db = self.db_session or next(get_db())
            
            count = 0
            for vuln in vulnerabilities:
                # Check if vulnerability with same resource_id and title already exists
                existing_vuln = db.query(Vulnerability).filter(
                    Vulnerability.resource_id == vuln.resource_id,
                    Vulnerability.title == vuln.title
                ).first()
                
                if existing_vuln:
                    # Update existing vulnerability
                    existing_vuln.description = vuln.description
                    existing_vuln.severity = vuln.severity
                    existing_vuln.updated_at = datetime.utcnow()
                    
                    # Only update status if it's open (don't overwrite manual status changes)
                    if existing_vuln.status == VulnerabilityStatus.OPEN:
                        existing_vuln.status = vuln.status
                else:
                    # Add new vulnerability
                    db.add(vuln)
                    count += 1
            
            db.commit()
            logger.info(f"Stored {count} new vulnerabilities in database")
            return count
            
        except Exception as e:
            logger.error(f"Error storing vulnerabilities: {e}")
            if db and not self.db_session:
                db.rollback()
            return 0
            
    async def get_vulnerabilities(self, 
                                  cloud_provider: Optional[str] = None,
                                  severity: Optional[List[str]] = None,
                                  status: Optional[List[str]] = None,
                                  resource_type: Optional[str] = None,
                                  region: Optional[str] = None,
                                  limit: int = 100,
                                  offset: int = 0) -> List[Vulnerability]:
        """
        Retrieve vulnerabilities from the database with optional filters.
        
        Args:
            cloud_provider: Filter by cloud provider (AWS, Azure, etc.)
            severity: Filter by severity levels
            status: Filter by status
            resource_type: Filter by resource type
            region: Filter by region
            limit: Maximum number of results
            offset: Pagination offset
            
        Returns:
            List of Vulnerability objects matching the filters
        """
        try:
            db = self.db_session or next(get_db())
            
            query = db.query(Vulnerability)
            
            # Apply filters
            if cloud_provider:
                query = query.filter(Vulnerability.cloud_provider == cloud_provider)
                
            if severity:
                query = query.filter(Vulnerability.severity.in_(severity))
                
            if status:
                query = query.filter(Vulnerability.status.in_(status))
                
            if resource_type:
                query = query.filter(Vulnerability.resource_type == resource_type)
                
            if region:
                query = query.filter(Vulnerability.region == region)
                
            # Order by severity and detection date
            query = query.order_by(Vulnerability.severity, Vulnerability.detected_at.desc())
            
            # Apply pagination
            query = query.limit(limit).offset(offset)
            
            result = query.all()
            logger.info(f"Retrieved {len(result)} vulnerabilities from database")
            return result
            
        except Exception as e:
            logger.error(f"Error retrieving vulnerabilities: {e}")
            return []
            
    async def get_vulnerability_by_id(self, vulnerability_id: str) -> Optional[Vulnerability]:
        """
        Retrieve a specific vulnerability by ID.
        
        Args:
            vulnerability_id: ID of the vulnerability to retrieve
            
        Returns:
            Vulnerability object if found, None otherwise
        """
        try:
            db = self.db_session or next(get_db())
            vulnerability = db.query(Vulnerability).filter(Vulnerability.id == vulnerability_id).first()
            return vulnerability
            
        except Exception as e:
            logger.error(f"Error retrieving vulnerability {vulnerability_id}: {e}")
            return None
            
    async def update_vulnerability_status(self, vulnerability_id: str, 
                                         new_status: VulnerabilityStatus) -> bool:
        """
        Update the status of a vulnerability.
        
        Args:
            vulnerability_id: ID of the vulnerability to update
            new_status: New status to set
            
        Returns:
            True if update was successful, False otherwise
        """
        try:
            db = self.db_session or next(get_db())
            vulnerability = db.query(Vulnerability).filter(Vulnerability.id == vulnerability_id).first()
            
            if not vulnerability:
                logger.warning(f"Vulnerability {vulnerability_id} not found")
                return False
                
            vulnerability.status = new_status
            vulnerability.updated_at = datetime.utcnow()
            
            # If status is resolved, set resolved_at timestamp
            if new_status == VulnerabilityStatus.RESOLVED:
                vulnerability.resolved_at = datetime.utcnow()
                
            db.commit()
            logger.info(f"Updated vulnerability {vulnerability_id} status to {new_status}")
            return True
            
        except Exception as e:
            logger.error(f"Error updating vulnerability status: {e}")
            if db and not self.db_session:
                db.rollback()
            return False
            
    async def add_compliance_finding(self, vulnerability_id: str, finding: ComplianceFinding) -> bool:
        """
        Add a compliance finding to a vulnerability.
        
        Args:
            vulnerability_id: ID of the vulnerability to add the finding to
            finding: ComplianceFinding object to add
            
        Returns:
            True if add was successful, False otherwise
        """
        try:
            db = self.db_session or next(get_db())
            vulnerability = db.query(Vulnerability).filter(Vulnerability.id == vulnerability_id).first()
            
            if not vulnerability:
                logger.warning(f"Vulnerability {vulnerability_id} not found")
                return False
                
            finding.vulnerability_id = vulnerability_id
            db.add(finding)
            db.commit()
            logger.info(f"Added compliance finding to vulnerability {vulnerability_id}")
            return True
            
        except Exception as e:
            logger.error(f"Error adding compliance finding: {e}")
            if db and not self.db_session:
                db.rollback()
            return False
            
    async def get_statistics(self) -> Dict[str, Any]:
        """
        Get statistical information about vulnerabilities.
        
        Returns:
            Dictionary with vulnerability statistics
        """
        try:
            db = self.db_session or next(get_db())
            
            # Total count
            total_count = db.query(Vulnerability).count()
            
            # Count by severity
            severity_counts = {}
            for severity in SeverityLevel:
                count = db.query(Vulnerability).filter(Vulnerability.severity == severity).count()
                severity_counts[severity.value] = count
                
            # Count by status
            status_counts = {}
            for status in VulnerabilityStatus:
                count = db.query(Vulnerability).filter(Vulnerability.status == status).count()
                status_counts[status.value] = count
                
            # Count by cloud provider
            provider_counts = {}
            providers_query = db.query(Vulnerability.cloud_provider, 
                                     db.func.count(Vulnerability.id)
                                    ).group_by(Vulnerability.cloud_provider).all()
            for provider, count in providers_query:
                provider_counts[provider.value] = count
                
            # Count by resource type
            resource_type_counts = {}
            resource_types_query = db.query(Vulnerability.resource_type,
                                           db.func.count(Vulnerability.id)
                                          ).group_by(Vulnerability.resource_type).all()
            for resource_type, count in resource_types_query:
                resource_type_counts[resource_type] = count
                
            # Recent vulnerabilities (last 24 hours)
            recent_count = db.query(Vulnerability).filter(
                Vulnerability.detected_at >= datetime.utcnow() - datetime.timedelta(days=1)
            ).count()
            
            return {
                "total": total_count,
                "by_severity": severity_counts,
                "by_status": status_counts,
                "by_cloud_provider": provider_counts,
                "by_resource_type": resource_type_counts,
                "recent_24h": recent_count
            }
            
        except Exception as e:
            logger.error(f"Error getting vulnerability statistics: {e}")
            return {
                "total": 0,
                "by_severity": {},
                "by_status": {},
                "by_cloud_provider": {},
                "by_resource_type": {},
                "recent_24h": 0
            }