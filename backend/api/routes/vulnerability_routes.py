from fastapi import APIRouter, Depends, HTTPException, Query
from pydantic import BaseModel
from typing import List, Optional, Dict, Any
from datetime import datetime
import os

from sqlalchemy.orm import Session
from ..models.database import get_db
from ...scanners.vulnerability_db import VulnerabilityDatabase
from ..models.vulnerability import SeverityLevel, CloudProvider, VulnerabilityStatus, ComplianceFinding

router = APIRouter()

# Pydantic models for request/response
class VulnerabilityResponse(BaseModel):
    id: str
    title: str
    description: str
    resource_id: str
    resource_type: str
    cloud_provider: str
    region: str
    severity: str
    status: str
    cvss_score: Optional[float] = None
    remediation_steps: Optional[str] = None
    detected_at: datetime
    updated_at: datetime
    resolved_at: Optional[datetime] = None
    
    class Config:
        orm_mode = True

class ComplianceFindingResponse(BaseModel):
    id: str
    vulnerability_id: str
    standard: str
    control_id: str
    description: str
    is_compliant: bool
    evidence: Optional[str] = None
    
    class Config:
        orm_mode = True

class ComplianceFindingCreate(BaseModel):
    standard: str
    control_id: str
    description: str
    is_compliant: bool
    evidence: Optional[str] = None

class StatusUpdate(BaseModel):
    status: str

@router.get("/", response_model=List[VulnerabilityResponse])
async def get_all_vulnerabilities(
    cloud_provider: Optional[str] = Query(None),
    severity: Optional[List[str]] = Query(None),
    status: Optional[List[str]] = Query(None),
    resource_type: Optional[str] = Query(None),
    region: Optional[str] = Query(None),
    limit: int = Query(100, gt=0, le=1000),
    offset: int = Query(0, ge=0),
    db: Session = Depends(get_db)
):
    """
    Get all vulnerabilities with optional filters
    """
    try:
        db_interface = VulnerabilityDatabase(db_session=db)
        
        # Convert string severity to enum if provided
        severity_enums = None
        if severity:
            try:
                severity_enums = [SeverityLevel(s.lower()) for s in severity]
            except ValueError:
                raise HTTPException(
                    status_code=400,
                    detail=f"Invalid severity value. Must be one of: {[s.value for s in SeverityLevel]}"
                )
        
        # Convert string status to enum if provided
        status_enums = None
        if status:
            try:
                status_enums = [VulnerabilityStatus(s.lower()) for s in status]
            except ValueError:
                raise HTTPException(
                    status_code=400,
                    detail=f"Invalid status value. Must be one of: {[s.value for s in VulnerabilityStatus]}"
                )
        
        # Convert string cloud provider to enum if provided
        cloud_provider_enum = None
        if cloud_provider:
            try:
                cloud_provider_enum = CloudProvider(cloud_provider.lower()).value
            except ValueError:
                raise HTTPException(
                    status_code=400,
                    detail=f"Invalid cloud provider value. Must be one of: {[p.value for p in CloudProvider]}"
                )
        
        vulnerabilities = await db_interface.get_vulnerabilities(
            cloud_provider=cloud_provider_enum,
            severity=severity_enums,
            status=status_enums,
            resource_type=resource_type,
            region=region,
            limit=limit,
            offset=offset
        )
        
        return vulnerabilities
    
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Error retrieving vulnerabilities: {str(e)}"
        )

@router.get("/{vulnerability_id}", response_model=VulnerabilityResponse)
async def get_vulnerability_by_id(
    vulnerability_id: str,
    db: Session = Depends(get_db)
):
    """
    Get a vulnerability by ID
    """
    try:
        db_interface = VulnerabilityDatabase(db_session=db)
        vulnerability = await db_interface.get_vulnerability_by_id(vulnerability_id)
        
        if not vulnerability:
            raise HTTPException(
                status_code=404,
                detail=f"Vulnerability with ID {vulnerability_id} not found"
            )
        
        return vulnerability
    
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Error retrieving vulnerability: {str(e)}"
        )

@router.post("/{vulnerability_id}/status")
async def update_vulnerability_status(
    vulnerability_id: str,
    status_update: StatusUpdate,
    db: Session = Depends(get_db)
):
    """
    Update the status of a vulnerability
    """
    try:
        # Validate status
        try:
            status_enum = VulnerabilityStatus(status_update.status.lower())
        except ValueError:
            raise HTTPException(
                status_code=400,
                detail=f"Invalid status value. Must be one of: {[s.value for s in VulnerabilityStatus]}"
            )
        
        db_interface = VulnerabilityDatabase(db_session=db)
        success = await db_interface.update_vulnerability_status(
            vulnerability_id=vulnerability_id,
            new_status=status_enum
        )
        
        if not success:
            raise HTTPException(
                status_code=404,
                detail=f"Vulnerability with ID {vulnerability_id} not found"
            )
        
        return {"status": "success", "message": f"Status updated to {status_update.status}"}
    
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Error updating vulnerability status: {str(e)}"
        )

@router.get("/{vulnerability_id}/compliance", response_model=List[ComplianceFindingResponse])
async def get_compliance_findings(
    vulnerability_id: str,
    db: Session = Depends(get_db)
):
    """
    Get compliance findings for a vulnerability
    """
    try:
        # Check if vulnerability exists
        db_interface = VulnerabilityDatabase(db_session=db)
        vulnerability = await db_interface.get_vulnerability_by_id(vulnerability_id)
        
        if not vulnerability:
            raise HTTPException(
                status_code=404,
                detail=f"Vulnerability with ID {vulnerability_id} not found"
            )
        
        # Get compliance findings
        findings = db.query(ComplianceFinding).filter(
            ComplianceFinding.vulnerability_id == vulnerability_id
        ).all()
        
        return findings
    
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Error retrieving compliance findings: {str(e)}"
        )

@router.post("/{vulnerability_id}/compliance", response_model=ComplianceFindingResponse)
async def add_compliance_finding(
    vulnerability_id: str,
    finding: ComplianceFindingCreate,
    db: Session = Depends(get_db)
):
    """
    Add a compliance finding to a vulnerability
    """
    try:
        # Check if vulnerability exists
        db_interface = VulnerabilityDatabase(db_session=db)
        vulnerability = await db_interface.get_vulnerability_by_id(vulnerability_id)
        
        if not vulnerability:
            raise HTTPException(
                status_code=404,
                detail=f"Vulnerability with ID {vulnerability_id} not found"
            )
        
        # Create compliance finding
        import uuid
        compliance_finding = ComplianceFinding(
            id=str(uuid.uuid4()),
            vulnerability_id=vulnerability_id,
            standard=finding.standard,
            control_id=finding.control_id,
            description=finding.description,
            is_compliant=finding.is_compliant,
            evidence=finding.evidence
        )
        
        # Add to database
        success = await db_interface.add_compliance_finding(
            vulnerability_id=vulnerability_id,
            finding=compliance_finding
        )
        
        if not success:
            raise HTTPException(
                status_code=500,
                detail="Failed to add compliance finding"
            )
        
        return compliance_finding
    
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Error adding compliance finding: {str(e)}"
        )

@router.get("/statistics/overview")
async def get_vulnerability_statistics(db: Session = Depends(get_db)):
    """
    Get overview statistics for all vulnerabilities
    """
    try:
        db_interface = VulnerabilityDatabase(db_session=db)
        stats = await db_interface.get_statistics()
        return stats
    
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Error retrieving vulnerability statistics: {str(e)}"
        )

@router.get("/severityLevels")
async def get_severity_levels():
    """
    Get all possible severity levels
    """
    return {
        "severity_levels": [level.value for level in SeverityLevel]
    }

@router.get("/statusValues")
async def get_status_values():
    """
    Get all possible vulnerability status values
    """
    return {
        "status_values": [status.value for status in VulnerabilityStatus]
    }

@router.get("/cloudProviders")
async def get_cloud_providers():
    """
    Get all supported cloud providers
    """
    return {
        "cloud_providers": [provider.value for provider in CloudProvider]
    }